<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Bible Bison</title>
  <link rel="stylesheet" href="styles.css">
  <link rel="icon" href="img/bilboicon01.png" type="image/png">
  <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
</head>

<body>
  <h1>Verse of the Day</h1>

  <!-- Date & optional time -->
  <div id="datetime">
    <p id="date"></p>
    <!--<p id="time"></p>-->
  </div>

  <!-- Preload hover image -->
  <script>
    const hoverImg = new Image();
    hoverImg.src = "img/Bilbo_The_Bison777t2.png"; // preload
  </script>

  <script>
    function updateDateTime() {
      const now = new Date();
      const options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
      document.getElementById("date").textContent = now.toLocaleDateString(undefined, options);
      document.getElementById("time").textContent = now.toLocaleTimeString();
    }
    updateDateTime();
    setInterval(updateDateTime, 1000);
  </script>

  <!-- Verse of the Day -->
  <div id="verse" class="fade-in"></div>

  <script>
    async function loadVerse() {
      try {
        const response = await fetch("https://beta.ourmanna.com/api/v1/get/?format=text");
        const verse = await response.text();
        document.getElementById("verse").innerText = verse;
      } catch {
        document.getElementById("verse").innerText = "Verse of the Day unavailable.";
      }
    }
    loadVerse();
  </script>

  <!-- Bilbo Image -->
  <img src="img/Bilbo_The_Bison777.png" class="bilbo-wrapper">

  <!-- Discuss Verse Button -->
  <button id="connectBtn">Discuss Verse</button>

  <!-- Connection Status -->
  <p id="connectionStatus" style="text-align:center; margin-top:10px; font-weight:bold;"></p>

  <!-- Container for all remote audio -->
  <div id="audioContainer"></div>

<script>
const ROOM_ID = "BibleBisonRoom";
const peers = {};
let peer;
let localStream;
let isHub = false;
let hubId = ROOM_ID;
let hubReady = false;
const queuedParticipants = [];

// Initialize PeerJS
function initPeer() {
  const hubCandidate = new Peer(ROOM_ID, {
    config: {
      iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'turn:TURN_SERVER_URL', username: 'USER', credential: 'PASS' }
      ]
    }
  });

  hubCandidate.on("open", id => {
    if (id === ROOM_ID) {
      peer = hubCandidate;
      isHub = true;
      setupPeer();
      console.log("I am the HUB!");
    }
  });

  hubCandidate.on("error", err => {
    if (err.type === "unavailable-id") {
      console.log("Hub exists, joining as participant...");
      peer = new Peer(null, {
        config: {
          iceServers: [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'turn:TURN_SERVER_URL', username: 'USER', credential: 'PASS' }
          ]
        }
      });
      isHub = false;
      setupPeer();
    }
  });
}

// Setup peer logic
function setupPeer() {
  peer.on("open", id => {
    console.log("Peer ID:", id, isHub ? "(Hub)" : "(Participant)");
  });

  // Answer incoming calls
  peer.on("call", call => {
    if (localStream) call.answer(localStream);
    else {
      const interval = setInterval(() => {
        if (localStream) {
          call.answer(localStream);
          clearInterval(interval);
        }
      }, 100);
    }
    call.on("stream", remoteStream => addAudioStream(call.peer, remoteStream));
  });


const connectedPeerIds = []; // track all connected peers (hub does not include itself)

if (isHub) {
  peer.on("connection", conn => {
    conn.on("data", data => {
      if (data.join) {
        console.log("New participant joined:", data.join);

        // Add new participant to connectedPeerIds
        if (!connectedPeerIds.includes(data.join)) connectedPeerIds.push(data.join);

        // Connect them if hub ready
        if (hubReady) connectToNewUser(data.join, localStream);
        else queuedParticipants.push(data.join);

        // Notify all existing peers about the new participant
        Object.values(peer.connections).forEach(conns => {
          conns.forEach(c => {
            if (c.peer !== data.join) c.send({ join: data.join });
          });
        });

        // Tell the new participant about all existing peers
        connectedPeerIds.forEach(existingId => {
          if (existingId !== data.join) conn.send({ join: existingId });
        });

        // Also send the hub's own ID
        conn.send({ join: ROOM_ID });

        // Notify everyone to update connection count
        Object.values(peer.connections).forEach(conns => {
          conns.forEach(c => c.send({ updateStatus: true }));
        });
      }

      // Participant receives updateStatus
      if (data.updateStatus) updateConnectionStatus();
    });
  });
}

}

// Participant connects to hub
function connectToHub() {
  if (!peer || !localStream) return;

  const conn = peer.connect(hubId);
  conn.on("open", () => conn.send({ join: peer.id }));
  conn.on("data", data => {
    if (data.join && data.join !== peer.id) connectToNewUser(data.join, localStream);
    if (data.updateStatus) updateConnectionStatus();
  });
}

// Connect to a peer for audio
function connectToNewUser(userId, stream) {
  if (!stream || peers[userId]) return;

  const call = peer.call(userId, stream);
  call.on("stream", remoteStream => addAudioStream(userId, remoteStream));
  call.on("close", () => {
    removeAudioStream(userId);
    delete peers[userId];
    updateConnectionStatus();
  });

  peers[userId] = call;
  updateConnectionStatus();
}

// Add audio
function addAudioStream(id, stream) {
  if (document.getElementById("audio-" + id)) return;
  const audio = document.createElement("audio");
  audio.id = "audio-" + id;
  audio.srcObject = stream;
  audio.autoplay = true;
  audio.play().catch(() => {});
  document.getElementById("audioContainer").appendChild(audio);
}

// Remove audio
function removeAudioStream(id) {
  const audio = document.getElementById("audio-" + id);
  if (audio) audio.remove();
  delete peers[id];
  updateConnectionStatus();
}

// Update connection count
function updateConnectionStatus() {
  let count = Object.keys(peers).length;

  if (!localStream) {
    document.getElementById("connectionStatus").textContent = "";
    return;
  }

  // Only add 1 if participant connected to hub
  if (!isHub && hubReady) count += 1;

  const statusEl = document.getElementById("connectionStatus");
  if (count === 0) statusEl.textContent = "You are the only one here.";
  else statusEl.textContent = `Connected with ${count} other user${count > 1 ? "s" : ""}.`;
}

// Request mic
async function requestMic() {
  if (!localStream) {
    try { localStream = await navigator.mediaDevices.getUserMedia({ audio: true }); }
    catch { alert("Microphone access is required."); return false; }
  }

  if (isHub) {
    hubReady = true;
    queuedParticipants.forEach(userId => connectToNewUser(userId, localStream));
    queuedParticipants.length = 0;
  } else {
    connectToHub();
  }
}

// Button click
document.getElementById("connectBtn").onclick = async () => {
  await requestMic();
  updateConnectionStatus();
};

// Start PeerJS
initPeer();
</script>

</body>
</html>
