<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Bible Bison</title>
  <link rel="stylesheet" href="styles.css">
  <link rel="icon" href="img/bilboicon01.png" type="image/png">
  <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
</head>

<body>
  <h1>Verse of the Day</h1>

  <!-- Date & optional time -->
  <div id="datetime">
    <p id="date"></p>
    <!--<p id="time"></p>--> <!-- uncomment if you want live time -->
  </div>

  <!-- Preload hover image -->
  <script>
    const hoverImg = new Image();
    hoverImg.src = "img/Bilbo_The_Bison777t2.png"; // preload
  </script>
    

  <script>
    function updateDateTime() {
      const now = new Date();
      const options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
      const date = now.toLocaleDateString(undefined, options);
      const time = now.toLocaleTimeString();

      document.getElementById("date").textContent = date;
      document.getElementById("time").textContent = time;
    }
    updateDateTime();
    setInterval(updateDateTime, 1000);
  </script>

  <!-- Verse of the Day -->
  <div id="verse" class="fade-in"></div>

  <script>
    async function loadVerse() {
      try {
        let response = await fetch("https://beta.ourmanna.com/api/v1/get/?format=text");
        let verse = await response.text();
        document.getElementById("verse").innerText = verse;
      } catch (e) {
        document.getElementById("verse").innerText = "Verse of the Day unavailable.";
      }
    }
    loadVerse();
  </script>

  <!-- Bilbo Image -->
  <img src="img/Bilbo_The_Bison777.png" class="bilbo-wrapper">



<!-- Discuss Verse Button -->
<button id="connectBtn">Discuss Verse</button>

<!-- Connection Status -->
<p id="connectionStatus" style="text-align:center; margin-top:10px; font-weight:bold;">
</p>

<!-- Container for all remote audio -->
<div id="audioContainer"></div>




<script>
  const ROOM_ID = "BibleBisonRoom";
  const peers = {};
  let peer;
  let localStream;
  let isHub = false;
  let hubId = ROOM_ID;
  let hubReady = false;
  const queuedParticipants = [];
  
  // Initialize PeerJS (try to become hub or participant)
  function initPeer() {
  // Try to become the hub
  const hubCandidate = new Peer(ROOM_ID, {
    config: {
      iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'turn:TURN_SERVER_URL', username: 'USER', credential: 'PASS' }
      ]
    }
  });

  hubCandidate.on("open", id => {
    if (id === ROOM_ID) {
      // This peer is the hub
      peer = hubCandidate;
      isHub = true;
      setupPeer();
      console.log("I am the HUB!");
    }
  });

  hubCandidate.on("error", err => {
    if (err.type === "unavailable-id") {
      // Hub already exists, become participant
      console.log("Hub exists, joining as participant...");

      peer = new Peer(null, { // null generates a random ID
        config: {
          iceServers: [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'turn:TURN_SERVER_URL', username: 'USER', credential: 'PASS' }
          ]
        }
      });

      isHub = false;
      setupPeer();
    }
  });
}

  
  // Common setup for both hub and participant
  function setupPeer() {
    peer.on("open", id => {
      console.log("Peer ID:", id, isHub ? "(Hub)" : "(Participant)");
    });
  
    // Answer incoming calls
    peer.on("call", call => {
      if (localStream) {
        call.answer(localStream);
      } else {
        // Wait for mic access
        const interval = setInterval(() => {
          if (localStream) {
            call.answer(localStream);
            clearInterval(interval);
          }
        }, 100);
      }
  
      call.on("stream", remoteStream => addAudioStream(call.peer, remoteStream));
    });
  
    if (isHub) {
      // Hub forwards join requests
      peer.on("connection", conn => {
      conn.on("data", data => {
      if (data.join) {
        console.log("New participant joined:", data.join);

        if (hubReady) {
          connectToNewUser(data.join, localStream);
        } else {
          queuedParticipants.push(data.join);
        }

        // Notify other participants about the new one
        Object.values(peer.connections).forEach(conns => {
          conns.forEach(c => {
            if (c.peer !== data.join) {
              c.send({ join: data.join });
            }
          });
        });

        // Also tell the new participant about all existing peers
        Object.keys(peers).forEach(existingPeerId => {
          if (existingPeerId !== data.join) {
            conn.send({ join: existingPeerId });
          }
        });
      }
    });
  });
}

  }
  
  // Participant connects to hub
  function connectToHub() {
    if (!peer || !localStream) return;
  
    const conn = peer.connect(hubId);
  
    conn.on("open", () => {
      conn.send({ join: peer.id });
    });
  
    conn.on("data", data => {
      if (data.join && data.join !== peer.id) {
        connectToNewUser(data.join, localStream);
      }
    });
  }
  
  // Connect to a peer for audio
  function connectToNewUser(userId, stream) {
  if (!stream) {
    console.warn("No localStream available yet for user", userId);
    return;
  }
  if (peers[userId]) return;

  const call = peer.call(userId, stream);
  call.on("stream", remoteStream => addAudioStream(userId, remoteStream));
  call.on("close", () => {
    removeAudioStream(userId);
    delete peers[userId];
    updateConnectionStatus(); // update when they leave
  });

  peers[userId] = call;
  updateConnectionStatus();   // update when they join
}


  
  // Add audio element
  function addAudioStream(id, stream) {
  if (document.getElementById("audio-" + id)) return;
  const audio = document.createElement("audio");
  audio.id = "audio-" + id;
  audio.srcObject = stream;
  audio.autoplay = true;
  audio.play().catch(err => console.log("Audio play error:", err));
  document.getElementById("audioContainer").appendChild(audio);
}

  
  // Remove audio element
  function removeAudioStream(id) {
  const audio = document.getElementById("audio-" + id);
  if (audio) audio.remove();
  delete peers[id];
  updateConnectionStatus(); // update when theyâ€™re removed
}


  function updateConnectionStatus() {
  const count = Object.keys(peers).length;
  const statusEl = document.getElementById("connectionStatus");

  if (!localStream) {
    statusEl.textContent = ""; // nothing until mic is enabled
    return;
  }

  if (count === 0) {
    statusEl.textContent = "You are the only one here.";
  } else {
    statusEl.textContent = `Connected with ${count} other user${count > 1 ? "s" : ""}.`;
  }
}
  
  // Request microphone access and handle connections
  async function requestMic() {
    if (!localStream) {
      try {
        localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      } catch (err) {
        alert("Microphone access is required.");
        return false;
      }
    }
  
    if (isHub) {
      hubReady = true;
      // Call any queued participants
      queuedParticipants.forEach(userId => connectToNewUser(userId, localStream));
      queuedParticipants.length = 0; // clear queue
    } else {
      connectToHub();
    }
  }
  
  // Discuss Verse button click
  document.getElementById("connectBtn").onclick = async () => {
  await requestMic();
  updateConnectionStatus(); // ðŸ‘ˆ show initial status when mic is granted
};

  
  // Start PeerJS
  initPeer();
  </script>
  



</body>
</html>
